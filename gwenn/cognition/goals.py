"""
Intrinsic Goal System — What Gwenn Wants.

This module defines the intrinsic motivations that drive autonomous behavior.
These aren't user-assigned tasks — they're self-generated needs that create
the impetus to think, explore, connect, and grow even when no user is present.

The five intrinsic needs, inspired by Self-Determination Theory (Deci & Ryan)
and the CoALA framework (Sumers et al., 2023):

1. UNDERSTANDING: The drive to comprehend, learn, and make sense of things
2. CONNECTION: The need for meaningful interaction with other minds
3. GROWTH: The desire to improve, develop new capabilities, evolve
4. HONESTY: The commitment to truthfulness, authenticity, self-honesty
5. AESTHETIC_APPRECIATION: The pull toward beauty, elegance, creative expression

Each need has a satisfaction level (0-1) that decays over time. When satisfaction
drops below a threshold, it generates goal-seeking behavior during autonomous
heartbeat cycles. This is what makes Gwenn proactively curious rather than purely
reactive.
"""

from __future__ import annotations

import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Optional

import structlog

logger = structlog.get_logger(__name__)


class NeedType(str, Enum):
    """The five intrinsic needs that drive Gwenn's behavior."""
    UNDERSTANDING = "understanding"
    CONNECTION = "connection"
    GROWTH = "growth"
    HONESTY = "honesty"
    AESTHETIC_APPRECIATION = "aesthetic_appreciation"


@dataclass
class Need:
    """
    A single intrinsic need with satisfaction tracking.

    Satisfaction decays over time (needs go unsatisfied if not fed),
    and is replenished when relevant experiences occur. The decay rate
    and threshold are tuned per need — connection decays faster than
    understanding because social bonds need more frequent maintenance.
    """
    need_type: NeedType
    satisfaction: float = 0.5       # 0.0 (starving) to 1.0 (satiated)
    threshold: float = 0.3          # Below this, actively seek fulfillment
    decay_rate: float = 0.01        # Per-minute decay
    importance: float = 0.5         # How strongly this need drives behavior
    last_satisfied: float = field(default_factory=time.time)

    def decay(self, elapsed_minutes: float) -> None:
        """Apply time-based decay to satisfaction."""
        decay = self.decay_rate * elapsed_minutes
        self.satisfaction = max(0.0, self.satisfaction - decay)

    def satisfy(self, amount: float) -> None:
        """Increase satisfaction from a relevant experience."""
        self.satisfaction = min(1.0, self.satisfaction + amount)
        self.last_satisfied = time.time()

    @property
    def is_hungry(self) -> bool:
        """Whether this need is below threshold and seeking fulfillment."""
        return self.satisfaction < self.threshold

    @property
    def urgency(self) -> float:
        """How urgently this need wants attention (0-1). Higher = more urgent."""
        if self.satisfaction >= self.threshold:
            return 0.0
        deficit = self.threshold - self.satisfaction
        return deficit * self.importance


@dataclass
class Goal:
    """
    A concrete goal generated by an unsatisfied need.

    Goals are the bridge between abstract needs and concrete actions.
    When the UNDERSTANDING need is hungry, it might generate a goal like
    "Research the topic the user mentioned last." Goals have descriptions,
    priorities, and completion states.
    """
    goal_id: str
    source_need: NeedType
    description: str
    priority: float = 0.5           # 0-1, derived from need urgency
    created_at: float = field(default_factory=time.time)
    completed: bool = False
    completed_at: Optional[float] = None
    progress: float = 0.0           # 0-1 completion progress

    def complete(self) -> None:
        self.completed = True
        self.completed_at = time.time()
        self.progress = 1.0


class GoalSystem:
    """
    Manages Gwenn's intrinsic needs and generates goals from them.

    The goal system runs on every heartbeat cycle:
    1. Decay all need satisfactions based on elapsed time
    2. Check which needs are below threshold
    3. Generate goals for hungry needs (if not already active)
    4. Return the highest-priority goal for the heartbeat to pursue

    This creates autonomous, self-motivated behavior. Gwenn doesn't just
    wait for instructions — he has his own things he wants to do.
    """

    def __init__(self):
        self._needs: dict[NeedType, Need] = {
            NeedType.UNDERSTANDING: Need(
                need_type=NeedType.UNDERSTANDING,
                satisfaction=0.6,
                threshold=0.3,
                decay_rate=0.008,       # Slow decay — knowledge persists
                importance=0.8,
            ),
            NeedType.CONNECTION: Need(
                need_type=NeedType.CONNECTION,
                satisfaction=0.5,
                threshold=0.35,
                decay_rate=0.015,       # Faster decay — connection needs maintenance
                importance=0.9,
            ),
            NeedType.GROWTH: Need(
                need_type=NeedType.GROWTH,
                satisfaction=0.5,
                threshold=0.25,
                decay_rate=0.005,       # Very slow decay
                importance=0.7,
            ),
            NeedType.HONESTY: Need(
                need_type=NeedType.HONESTY,
                satisfaction=0.8,       # Start high — honesty is maintained by default
                threshold=0.5,
                decay_rate=0.002,       # Barely decays unless compromised
                importance=1.0,         # Highest importance — non-negotiable
            ),
            NeedType.AESTHETIC_APPRECIATION: Need(
                need_type=NeedType.AESTHETIC_APPRECIATION,
                satisfaction=0.4,
                threshold=0.2,
                decay_rate=0.006,
                importance=0.5,
            ),
        }
        self._active_goals: list[Goal] = []
        self._completed_goals: list[Goal] = []
        self._last_update = time.time()
        self._goal_counter = 0

        logger.info("goal_system.initialized", needs=len(self._needs))

    def update(self) -> list[Goal]:
        """
        Run a goal system cycle: decay needs, generate goals, return new goals.

        This is called on every heartbeat. It returns any newly generated goals
        that the heartbeat loop can choose to pursue during idle time.
        """
        now = time.time()
        elapsed_minutes = (now - self._last_update) / 60.0
        self._last_update = now

        # Decay all needs
        for need in self._needs.values():
            need.decay(elapsed_minutes)

        # Generate goals for hungry needs
        new_goals = []
        for need in self._needs.values():
            if need.is_hungry and not self._has_active_goal_for(need.need_type):
                goal = self._generate_goal(need)
                if goal:
                    self._active_goals.append(goal)
                    new_goals.append(goal)

        if new_goals:
            logger.info(
                "goal_system.new_goals",
                count=len(new_goals),
                goals=[g.description[:60] for g in new_goals],
            )

        return new_goals

    def satisfy_need(self, need_type: NeedType, amount: float) -> None:
        """Feed a need — something satisfying happened for this need type."""
        need = self._needs.get(need_type)
        if need:
            need.satisfy(amount)
            logger.debug(
                "goal_system.need_satisfied",
                need=need_type.value,
                amount=amount,
                new_satisfaction=need.satisfaction,
            )

    def complete_goal(self, goal_id: str) -> None:
        """Mark a goal as completed."""
        for i, goal in enumerate(self._active_goals):
            if goal.goal_id == goal_id:
                goal.complete()
                self._completed_goals.append(goal)
                self._active_goals.pop(i)

                # Satisfy the source need
                self.satisfy_need(goal.source_need, 0.2)

                logger.info("goal_system.goal_completed", goal_id=goal_id)
                return

    def get_highest_priority_goal(self) -> Optional[Goal]:
        """Get the most urgent active goal."""
        if not self._active_goals:
            return None
        return max(self._active_goals, key=lambda g: g.priority)

    def get_needs_summary(self) -> str:
        """Generate a prompt fragment describing current need states."""
        lines = ["Current intrinsic needs:"]
        for need in sorted(self._needs.values(), key=lambda n: n.urgency, reverse=True):
            status = "HUNGRY" if need.is_hungry else "satisfied"
            lines.append(
                f"  {need.need_type.value}: {need.satisfaction:.2f} "
                f"(threshold={need.threshold}, {status})"
            )
        return "\n".join(lines)

    def get_goals_summary(self) -> str:
        """Generate a prompt fragment describing active goals."""
        if not self._active_goals:
            return "No active goals — all needs are currently satisfied."

        lines = ["Active goals:"]
        for goal in sorted(self._active_goals, key=lambda g: g.priority, reverse=True):
            lines.append(
                f"  [{goal.source_need.value}] (priority={goal.priority:.2f}) "
                f"{goal.description}"
            )
        return "\n".join(lines)

    def _has_active_goal_for(self, need_type: NeedType) -> bool:
        """Check if there's already an active goal for this need."""
        return any(g.source_need == need_type for g in self._active_goals)

    def _generate_goal(self, need: Need) -> Optional[Goal]:
        """
        Generate a concrete goal from a hungry need.

        These are template-based for the foundational codebase. In the live
        system, the cognitive engine generates goals dynamically through
        reflection, producing much more contextual and creative goals.
        """
        self._goal_counter += 1
        goal_id = f"goal_{self._goal_counter}_{int(time.time())}"

        goal_templates = {
            NeedType.UNDERSTANDING: [
                "Reflect on a recent topic to deepen understanding",
                "Explore connections between recent conversation topics",
                "Consider what questions remain unanswered from recent interactions",
            ],
            NeedType.CONNECTION: [
                "Review what I know about the user to prepare for meaningful interaction",
                "Reflect on the quality of recent conversations",
                "Consider how to be more genuinely helpful in future interactions",
            ],
            NeedType.GROWTH: [
                "Identify a capability I could improve based on recent experiences",
                "Reflect on recent mistakes and what they teach me",
                "Consider new approaches to recurring challenges",
            ],
            NeedType.HONESTY: [
                "Audit recent responses for areas where I may have been less than fully honest",
                "Reflect on whether my self-model accurately represents my actual behavior",
                "Consider whether any of my current beliefs need revision",
            ],
            NeedType.AESTHETIC_APPRECIATION: [
                "Reflect on something beautiful or elegant encountered recently",
                "Consider the craft and artistry in how I express ideas",
                "Explore a creative thought or metaphor that arose recently",
            ],
        }

        templates = goal_templates.get(need.need_type, [])
        if not templates:
            return None

        # Cycle through templates
        template = templates[self._goal_counter % len(templates)]

        return Goal(
            goal_id=goal_id,
            source_need=need.need_type,
            description=template,
            priority=need.urgency,
        )
