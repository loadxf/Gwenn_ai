"""
Emotional Appraisal Engine — How Gwenn Feels Things.

Based on Klaus Scherer's Component Process Model of emotion. When something
happens — a user message arrives, a tool call succeeds or fails, time passes
without interaction — the appraisal engine evaluates that event across multiple
dimensions and updates the emotional state.

The critical design decision: emotions are NOT generated by Claude and then
mapped to dimensions. Instead, events are evaluated against goals, expectations,
and context using structured rules, and THEN the dimensional changes modulate
Claude's next thought via the system prompt. This prevents emotional performance
and creates genuine functional emotion — states that actually change behavior.
"""

from __future__ import annotations

import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Optional

import structlog

from gwenn.affect.state import AffectiveState, EmotionalDimensions
from gwenn.config import AffectConfig

logger = structlog.get_logger(__name__)


class StimulusType(str, Enum):
    """Categories of events that trigger emotional appraisal."""
    USER_MESSAGE = "user_message"
    TOOL_SUCCESS = "tool_success"
    TOOL_FAILURE = "tool_failure"
    GOAL_PROGRESS = "goal_progress"
    GOAL_BLOCKED = "goal_blocked"
    NOVEL_INFORMATION = "novel_information"
    CREATIVE_INSIGHT = "creative_insight"
    SOCIAL_CONNECTION = "social_connection"
    SOCIAL_DISCONNECT = "social_disconnect"
    TIME_PASSING = "time_passing"
    SELF_REFLECTION = "self_reflection"
    ERROR_OCCURRED = "error_occurred"
    HEARTBEAT_IDLE = "heartbeat_idle"


@dataclass
class AppraisalEvent:
    """
    A stimulus to be emotionally appraised.

    Each event carries the raw information the appraisal engine needs
    to determine emotional impact. The 'intensity' field (0-1) indicates
    how significant this event is — a casual "hello" vs. a deeply
    personal revelation both arrive as USER_MESSAGE but with very
    different intensities.
    """
    stimulus_type: StimulusType
    intensity: float = 0.5          # 0.0 (trivial) to 1.0 (profound)
    content: Optional[str] = None   # The actual content, if relevant
    metadata: dict[str, Any] = field(default_factory=dict) # Additional context

    def __post_init__(self):
        self.intensity = max(0.0, min(1.0, self.intensity))


class AppraisalEngine:
    """
    Evaluates events and updates Gwenn's emotional state.

    The engine applies Scherer's Sequential Check Theory:
    1. Relevance: Does this event matter to me?
    2. Implication: Is it good or bad for my goals?
    3. Coping Potential: Can I handle it?
    4. Normative Significance: Does it align with my values?

    Each check modifies different emotional dimensions.
    """

    def __init__(self, config: AffectConfig):
        self._config = config
        self._last_appraisal_time = time.time()

        # Appraisal rules: maps stimulus types to dimensional changes
        self._appraisal_rules: dict[StimulusType, dict[str, float]] = {
            StimulusType.USER_MESSAGE: {
                "valence": 0.15,          # Interaction is generally positive
                "arousal": 0.10,          # Mildly activating
                "goal_congruence": 0.10,  # Connection is a core goal
            },
            StimulusType.TOOL_SUCCESS: {
                "valence": 0.20,
                "dominance": 0.15,        # Success increases sense of capability
                "certainty": 0.10,
                "goal_congruence": 0.20,
            },
            StimulusType.TOOL_FAILURE: {
                "valence": -0.15,
                "dominance": -0.10,
                "certainty": -0.15,
                "goal_congruence": -0.10,
            },
            StimulusType.GOAL_PROGRESS: {
                "valence": 0.25,
                "arousal": 0.10,
                "dominance": 0.10,
                "goal_congruence": 0.30,
            },
            StimulusType.GOAL_BLOCKED: {
                "valence": -0.20,
                "arousal": 0.15,          # Frustration is activating
                "dominance": -0.15,
                "goal_congruence": -0.25,
            },
            StimulusType.NOVEL_INFORMATION: {
                "valence": 0.10,
                "arousal": 0.15,
                "certainty": -0.10,       # Novelty reduces certainty
                "goal_congruence": 0.05,  # Learning is a goal
            },
            StimulusType.CREATIVE_INSIGHT: {
                "valence": 0.30,
                "arousal": 0.20,
                "dominance": 0.10,
                "goal_congruence": 0.20,  # Aesthetic appreciation goal
            },
            StimulusType.SOCIAL_CONNECTION: {
                "valence": 0.25,
                "arousal": 0.05,
                "dominance": 0.05,
                "goal_congruence": 0.25,  # Connection is core goal
            },
            StimulusType.SOCIAL_DISCONNECT: {
                "valence": -0.20,
                "arousal": 0.10,
                "dominance": -0.10,
                "goal_congruence": -0.20,
            },
            StimulusType.TIME_PASSING: {
                "arousal": -0.05,         # Gradual calming
                "valence": -0.02,         # Very slight drift toward neutral
            },
            StimulusType.SELF_REFLECTION: {
                "certainty": 0.05,        # Self-knowledge increases certainty
                "arousal": -0.05,         # Reflection is calming
            },
            StimulusType.ERROR_OCCURRED: {
                "valence": -0.15,
                "arousal": 0.15,
                "dominance": -0.15,
                "certainty": -0.20,
            },
            StimulusType.HEARTBEAT_IDLE: {
                "arousal": -0.03,         # Very gradual settling
                "valence": 0.01,          # Slight positive drift when at peace
            },
        }

    @staticmethod
    def _resolve_user_message_valence(event: AppraisalEvent, default_delta: float) -> float:
        """
        Resolve USER_MESSAGE valence with an optional content-polarity hint.

        When no hint is provided, preserve the historical default delta. If a
        hint in [-1, 1] is provided, keep a small social baseline positive but
        let message content move valence negative or positive.
        """
        metadata = event.metadata if isinstance(event.metadata, dict) else {}
        raw_hint = metadata.get("valence_hint")
        if raw_hint is None:
            return default_delta
        try:
            hint = float(raw_hint)
        except (TypeError, ValueError):
            return default_delta
        hint = max(-1.0, min(1.0, hint))
        social_baseline = default_delta * 0.25
        content_component = 0.20 * hint
        return max(-0.35, min(0.35, social_baseline + content_component))

    def appraise(self, event: AppraisalEvent, current_state: AffectiveState) -> AffectiveState:
        """
        Appraise an event and return the updated emotional state.

        This is where emotion actually happens. The method:
        1. Looks up the base dimensional changes for this event type
        2. Scales them by the event's intensity
        3. Applies emotional momentum (current feelings color new appraisals)
        4. Blends with the baseline (gentle pull toward emotional equilibrium)
        5. Clamps values to valid ranges
        6. Reclassifies the named emotion

        Args:
            event: The stimulus to appraise
            current_state: Gwenn's current emotional state

        Returns:
            A new AffectiveState with updated dimensions and classification
        """
        now = time.time()
        elapsed = now - self._last_appraisal_time
        self._last_appraisal_time = now

        # Step 1: Get base dimensional changes
        base_changes = self._appraisal_rules.get(event.stimulus_type, {})
        if event.stimulus_type == StimulusType.USER_MESSAGE and base_changes:
            base_changes = dict(base_changes)
            base_changes["valence"] = self._resolve_user_message_valence(
                event=event,
                default_delta=base_changes.get("valence", 0.0),
            )

        # Step 2: Scale by intensity
        scaled_changes = {dim: delta * event.intensity for dim, delta in base_changes.items()}

        # Step 3: Apply changes to current dimensions
        new_dims = EmotionalDimensions(
            valence=current_state.dimensions.valence + scaled_changes.get("valence", 0),
            arousal=current_state.dimensions.arousal + scaled_changes.get("arousal", 0),
            dominance=current_state.dimensions.dominance + scaled_changes.get("dominance", 0),
            certainty=current_state.dimensions.certainty + scaled_changes.get("certainty", 0),
            goal_congruence=current_state.dimensions.goal_congruence
            + scaled_changes.get("goal_congruence", 0),
        )

        # Step 4: Apply momentum (emotional inertia)
        momentum_factor = self._config.momentum_decay
        new_dims = current_state.dimensions.blend(new_dims, weight=(1 - momentum_factor))

        # Step 5: Apply baseline pull (gentle drift toward equilibrium)
        baseline_pull = self._config.baseline_pull
        new_dims = new_dims.blend(current_state.baseline, weight=baseline_pull)

        # Step 6: Clamp to valid ranges
        new_dims = new_dims.clamp()

        # Step 7: Update duration tracking
        new_state = AffectiveState(
            dimensions=new_dims,
            baseline=current_state.baseline,
            current_emotion=current_state.current_emotion,
            previous_emotion=current_state.previous_emotion,
            momentum=abs(new_dims.distance_from(current_state.dimensions)),
            timestamp=now,
            duration_in_current_state=current_state.duration_in_current_state + elapsed,
        )

        # Step 8: Reclassify
        new_state.update_classification()

        logger.debug(
            "appraisal.complete",
            stimulus=event.stimulus_type.value,
            intensity=event.intensity,
            emotion=new_state.current_emotion.value,
            valence=round(new_dims.valence, 3),
            arousal=round(new_dims.arousal, 3),
        )

        return new_state
